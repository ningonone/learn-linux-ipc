# 信号量和PV操作
## 概念
进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信。
为了，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步），我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：

1）P 操作：将信号量值减 1，表示申请占用一个资源。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。

可以这么理解，当信号量的值为 2 的时候，表示有 2 个资源可以使用，当信号量的值为 -2 的时候，表示有两个进程正在等待使用这个资源。不看这句话真的无法理解 V 操作，看完顿时如梦初醒。

2）V 操作：将信号量值加 1，表示释放一个资源，即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去。

## SystemV
### 相关函数
#### `semget`
- 获取一个信号量集的标识符。
- **函数原型**：
```c
int semget(key_t key, int nsems, int semflg);
```
- **参数**：
  - `key_t key`：信号量集的键值，用于唯一标识信号量集。
  - `int nsems`：信号量集中的信号量数量。
  - `int semflg`：标志位，用于设置信号量的创建和访问权限。
- **返回值**：成功返回信号量集的标识符，失败返回-1，并设置errno。

#### `semop`
- 对信号量执行操作（P操作和V操作）。
- **函数原型**：
```c
int semop(int semid, struct sembuf *sops, size_t nsops);
```
- **参数**：
  - `int semid`：信号量集的标识符。
  - `struct sembuf *sops`：指向操作数组的指针，每个操作包含信号量索引、操作类型和操作计数。
  - `size_t nsops`：操作数组中的操作数量。
- **返回值**：成功返回0，失败返回-1，并设置errno。

#### `semctl`
- 控制信号量集的操作，包括获取和设置信号量的值、删除信号量集等。
- **函数原型**：
```c
int semctl(int semid, int semnum, int cmd, ...);
```
- **参数**：
  - `int semid`：信号量集的标识符。
  - `int semnum`：信号量的索引（对于某些操作可以为0）。
  - `int cmd`：控制命令，指定要执行的操作（如获取值、设置值、删除等）。
  - `...`：用于传递额外参数的联合体（`union semun`），具体取决于cmd的值。
- **返回值**：成功返回操作结果，失败返回-1，并设置errno。

#### `union semun`
- 用于传递给 `semctl` 的参数。
- **定义**：
```c
union semun {
    int val;                // 用于SETVAL命令
    struct semid_ds *buf;  // 用于IPC_STAT和IPC_SET命令
    unsigned short *array;  // 用于GETALL和SETALL命令
    struct seminfo *__buf;  // 用于GETINFO命令
};
```

#### `struct sembuf`
- 定义信号量操作的结构体。
- **定义**：
```c
struct sembuf {
    unsigned short sem_num; // 信号量在信号量集中的索引
    short sem_op;           // 操作类型（正值表示V操作，负值表示P操作）
    short sem_flg;          // 操作标志（如IPC_NOWAIT）
};
```

# 消息队列
## 概念
**消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构**。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。对比一下管道机制：
- 消息队列允许一个或多个进程向它写入或读取消息。
- 消息队列可以实现消息的随机查询，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。
- 对于消息队列来说，在某个进程往一个队列写入消息之前，并不需要另一个进程在该消息队列上等待消息的到达。而对于管道来说，除非读进程已存在，否则先有写进程进行写入操作是没有意义的。
- 消息队列的生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列就会一直存在。而匿名管道随进程的创建而建立，随进程的结束而销毁。

需要注意的是，消息队列对于交换较少数量的数据很有用，因为无需避免冲突。但是，由于用户进程写入数据到内存中的消息队列时，会发生从用户态拷贝数据到内核态的过程；同样的，另一个用户进程读取内存中的消息数据时，会发生从内核态拷贝数据到用户态的过程。因此，如果数据量较大，使用消息队列就会造成频繁的系统调用，也就是需要消耗更多的时间以便内核介入。

## SystemV
### 相关函数
#### `msgget`
- 创建一个新的消息队列或打开一个已存在的消息队列。
- `msgget` 函数使用一个唯一的键（key）来标识消息队列。如果指定的消息队列不存在，且调用者具有创建权限，则会创建一个新的消息队列；如果已存在，则返回该队列的标识符。

```c
int msgget(key_t key, int msgflg);
```
- **`key`**：由 `ftok` 生成的唯一键。
- **`msgflg`**：标志位，通常包括权限设置（如 `IPC_CREAT`、`IPC_EXCL` 等）。


#### `msgsnd`
- 向消息队列发送一条消息。
- `msgsnd` 将消息添加到指定的消息队列中。如果队列已满，调用者可以选择阻塞等待或立即返回（取决于标志位设置）。

```c
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```
- **`msqid`**：消息队列的标识符。
- **`msgp`**：指向消息结构的指针，消息结构必须包含消息类型。
- **`msgsz`**：消息内容的大小（不包括消息类型）。
- **`msgflg`**：标志位，控制行为（如阻塞或非阻塞）。
返回值：
- 成功时：返回0
- 失败时：返回-1

#### `msgrcv`
- 从消息队列接收一条消息。
- `msgrcv` 从指定的消息队列中读取消息。可以根据消息类型选择接收特定类型的消息。如果没有消息可读，调用者可以选择阻塞等待或立即返回（取决于标志位设置）。

```c
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```
- **`msqid`**：消息队列的标识符。
- **`msgp`**：指向接收消息的结构的指针。
- **`msgsz`**：接收消息内容的最大大小。
- **`msgtyp`**：指定要接收的消息类型（可以是特定类型或 0 表示接收任何类型）。
- **`msgflg`**：标志位，控制行为（如阻塞或非阻塞）。
返回值：
- 成功时：返回实际接收到的消息的字节数。
- 失败时：返回 -1，并设置 errno 以指示错误原因。

#### `msgctl`
- 控制消息队列的操作，如删除消息队列或获取消息队列的状态信息。
- `msgctl` 可以用于多种操作，包括删除消息队列、获取队列的状态信息等。通过传递不同的命令，可以实现不同的功能。

```c
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```
- **`msqid`**：消息队列的标识符。
- **`cmd`**：控制命令（如 `IPC_RMID` 删除队列，`IPC_STAT` 获取状态等）。
- **`buf`**：指向 `msqid_ds` 结构的指针，用于存储状态信息（如果需要）。

#### `ftok`
- 生成一个唯一的键，用于标识 IPC 资源（如消息队列）。
- `ftok` 根据给定的文件路径和项目标识符生成一个唯一的键。这个键可以用于 `msgget` 函数来创建或访问消息队列。

```c
key_t ftok(const char *pathname, int proj_id);
```
- **`pathname`**：一个存在的文件路径。
- **`proj_id`**：一个项目标识符，通常是一个小的整数。

### 总结
System V 消息队列的主要函数提供了创建、发送、接收和管理消息队列的功能。通过这些函数，进程可以方便地进行异步通信，确保数据的可靠传输。每个函数的设计都考虑到了进程间的同步和数据完整性，使得消息队列成为一种有效的 IPC 机制。


### 消息队列是如何按顺序读取消息的？
在 Linux 消息队列中，消息的读取顺序主要依赖于消息的类型和发送的顺序。消息队列的读取机制通常遵循以下几个原则：

1. **消息类型**：每条消息都有一个与之关联的类型字段（通常是一个正整数）。在接收消息时，进程可以选择接收特定类型的消息，或者接收队列中的任意消息。

2. **优先级处理**：消息队列支持优先级机制。接收消息时，如果指定了消息类型，内核会优先返回该类型的消息。如果有多个相同类型的消息，内核会按照它们被发送的顺序（先进先出，FIFO）进行处理。

3. **先进先出（FIFO）**：在同一类型的消息中，消息的接收顺序是先进先出（FIFO）。这意味着最早发送的消息会最先被接收，确保消息的顺序性。

#### 读取消息的过程：

1. **接收系统调用**：进程通过 `msgrcv` 系统调用来接收消息。可以指定要接收的消息类型。

2. **查找消息**：内核会在消息队列中查找符合条件的消息。如果指定了消息类型，内核会查找该类型的消息；如果没有指定类型，内核会查找队列中的任意消息。

3. **返回消息**：一旦找到符合条件的消息，内核会将其从队列中移除，并将消息内容复制到用户提供的缓冲区中。

4. **顺序保证**：如果有多个符合条件的消息，内核会按照它们的发送顺序返回消息，确保消息的顺序性。

#### 示例：

假设有三个消息，类型分别为 1、1 和 2，发送顺序为：

- 发送消息 1（类型 1）
- 发送消息 2（类型 1）
- 发送消息 3（类型 2）

如果接收进程调用 `msgrcv` 并指定接收类型为 1，它将首先接收到消息 1，然后是消息 2。如果接收进程调用 `msgrcv` 并指定接收类型为 2，它将接收到消息 3。

总之，Linux 消息队列通过消息类型和先进先出的原则来确保消息的顺序读取。

### 关于消息队列的大小？
通常可以通过`msgctl`去配置消息队列的大小并进行管理，如果没有设置，默认的最大消息大小、最大消息数可以通过`/proc/sys/kernel/msgmax`和`/proc/sys/kernel/msgmni`进行查看。


## Posix
用的不多暂时搁置。
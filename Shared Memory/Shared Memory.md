# 共享内存
## System V
### 相关函数
#### `shmget`
- 创建一个新的共享内存段或获取一个已存在的共享内存段的标识符。
- **原型**：
```c
int shmget(key_t key, size_t size, int shmflg);
```
- **参数**：
  - `key`: 用于标识共享内存段的键值。
  - `size`: 共享内存段的大小（以字节为单位）。
  - `shmflg`: 标志位，通常包括 `IPC_CREAT`（如果共享内存段不存在则创建）和权限标志（如 `0666`）。
- **返回值**：
  - 成功时，返回共享内存段的标识符（非负整数）。
  - 失败时，返回 `-1`，并设置 `errno` 以指示错误原因。

#### `shmat`
- 将共享内存段映射到调用进程的地址空间。
- **原型**：
```c
void *shmat(int shmid, const void *shmaddr, int shmflg);
```
- **参数**：
  - `shmid`: 通过 `shmget` 返回的共享内存标识符。
  - `shmaddr`: 映射的起始地址（通常为 `NULL`，让系统选择地址）。
  - `shmflg`: 标志位，通常包括 `SHM_RDONLY`（只读）等。
- **返回值**：
  - 成功时，返回指向共享内存段的指针。
  - 失败时，返回 `(void *) -1`，并设置 `errno` 以指示错误原因。
    
#### `shmdt`
- 将共享内存段从调用进程的地址空间中分离。
- **原型**：
```c
int shmdt(const void *shmaddr);
```
- **参数**：
  - `shmaddr`: 之前通过 `shmat` 返回的指针，指向要分离的共享内存段。
- **返回值**：
  - 成功时，返回 `0`。
  - 失败时，返回 `-1`，并设置 `errno` 以指示错误原因。

#### `shmctl`
- 控制共享内存段的操作。
- **原型**：
```c
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
  ```
- **参数**：
  - `shmid`: 共享内存标识符。
  - `cmd`: 操作命令，常用的命令包括：
    - `IPC_STAT`: 获取共享内存段的状态信息。
    - `IPC_RMID`: 删除共享内存段。
  - `buf`: 指向 `shmid_ds` 结构的指针，用于获取或设置共享内存段的属性。
- **返回值**：
  - 成功时，返回 `0`。
  - 失败时，返回 `-1`，并设置 `errno` 以指示错误原因。

#### `shmid_ds` 结构
- **结构体**：
```c
struct shmid_ds {
    struct ipc_perm shm_perm; // 共享内存的权限
    size_t shm_segsz;         // 共享内存段的大小
    time_t shm_atime;         // 最后附加时间
    time_t shm_dtime;         // 最后分离时间
    time_t shm_ctime;         // 最后改变时间
    unsigned short shm_cpid;  // 创建该共享内存段的进程 ID
    unsigned short shm_lpid;   // 最后附加该共享内存段的进程 ID
    unsigned short shm_nattch; // 当前附加到该共享内存段的进程数
};
```


### 理解
- 共享内存是在用户空间开辟的内存，所以不需要陷入内核进行IO，这就是他效率比管道，消息列表高的原因
- 管道 和 消息列表 需要 进行上文切换的原因是在 CPU需要交由操作系统进行 内核空间中的内存读写，读写完毕 将控制权交还给内存。

### 关于访问控制
共享内存本身并不具备内置的访问控制或阻塞机制，这意味着它无法自动管理对共享内存的并发访问。这是因为共享内存的设计目标是提供高效的进程间通信，而不是处理同步和互斥问题。因此，使用共享内存时，开发者需要手动实现访问控制，以确保数据的一致性和防止竞争条件。
为了实现对共享内存的访问控制，通常使用以下几种机制：
1. 信号量
2. 互斥锁
3. 条件变量
4. 读写锁
5. 原子操作